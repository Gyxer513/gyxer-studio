import type { GyxerProject, Entity, Field, Relation } from '@gyxer/schema';
import { toSnakeCase } from '../utils.js';

/**
 * Generate a complete Prisma schema from a GyxerProject.
 */
export function generatePrismaSchema(project: GyxerProject): string {
  const lines: string[] = [];

  // Datasource
  lines.push('// This file is auto-generated by Gyxer Studio. Do not edit manually.');
  lines.push('');
  lines.push('generator client {');
  lines.push('  provider = "prisma-client-js"');
  lines.push('}');
  lines.push('');
  lines.push('datasource db {');
  lines.push(`  provider = "${project.settings.database}"`);
  lines.push('  url      = env("DATABASE_URL")');
  lines.push('}');

  // Enums
  for (const entity of project.entities) {
    for (const field of entity.fields) {
      if (field.type === 'enum' && field.enumValues && field.enumValues.length > 0) {
        const enumName = `${entity.name}${capitalize(field.name)}`;
        lines.push('');
        lines.push(`enum ${enumName} {`);
        for (const value of field.enumValues) {
          lines.push(`  ${value}`);
        }
        lines.push('}');
      }
    }
  }

  // Models
  for (const entity of project.entities) {
    lines.push('');
    lines.push(generateModel(entity, project));
  }

  // Auto-generate User model for auth-jwt when no User entity is defined
  const hasAuthJwt = project.modules?.some((m) => m.name === 'auth-jwt' && m.enabled !== false);
  const hasUserEntity = project.entities.some((e) => e.name === 'User');
  if (hasAuthJwt && !hasUserEntity) {
    lines.push('');
    lines.push(generateAuthUserModel());
  }

  return lines.join('\n') + '\n';
}

function generateModel(entity: Entity, project: GyxerProject): string {
  const lines: string[] = [];

  if (entity.description) {
    lines.push(`/// ${entity.description}`);
  }
  lines.push(`model ${entity.name} {`);

  // id field (always generated)
  lines.push('  id        Int      @id @default(autoincrement())');
  lines.push('  createdAt DateTime @default(now())');
  lines.push('  updatedAt DateTime @updatedAt');

  // Auth: add passwordHash to User model
  const hasAuthJwt = project.modules?.some((m) => m.name === 'auth-jwt' && m.enabled !== false);
  if (hasAuthJwt && entity.name === 'User') {
    lines.push('  passwordHash  String  @map("password_hash")');
  }

  // User-defined fields
  for (const field of entity.fields) {
    lines.push(`  ${generateField(field, entity)}`);
  }

  // Relations
  for (const relation of entity.relations) {
    lines.push(generateRelation(relation, entity, project));
  }

  // Auto-generate inverse relations (missing back-references)
  for (const otherEntity of project.entities) {
    if (otherEntity.name === entity.name) continue;

    for (const rel of otherEntity.relations) {
      if (rel.target !== entity.name) continue;

      // Skip if this entity already has a back-reference to otherEntity
      const hasBackRef = entity.relations.some((r) => r.target === otherEntity.name);
      if (hasBackRef) continue;

      lines.push(generateInverseRelation(rel, otherEntity));
    }
  }

  // Model-level indexes (@@index)
  const indexedFields = entity.fields.filter((f) => f.index && !f.unique);
  for (const field of indexedFields) {
    lines.push(`  @@index([${field.name}])`);
  }

  // Table mapping
  lines.push('');
  lines.push(`  @@map("${toSnakeCase(entity.name)}")`);
  lines.push('}');

  return lines.join('\n');
}

function generateField(field: Field, entity: Entity): string {
  const parts: string[] = [];

  // Name
  const columnName = toSnakeCase(field.name);
  parts.push(padRight(field.name, 14));

  // Type
  let prismaType = mapFieldType(field, entity);
  if (!field.required) {
    prismaType += '?';
  }
  parts.push(prismaType);

  // Attributes
  const attrs: string[] = [];

  if (field.unique) attrs.push('@unique');

  if (field.default !== undefined && field.default !== null) {
    if (field.type === 'boolean') {
      attrs.push(`@default(${field.default})`);
    } else if (field.type === 'int' || field.type === 'float') {
      attrs.push(`@default(${field.default})`);
    } else if (field.type === 'enum') {
      attrs.push(`@default(${field.default})`);
    } else {
      attrs.push(`@default("${field.default}")`);
    }
  }

  if (field.name !== columnName) {
    attrs.push(`@map("${columnName}")`);
  }

  if (attrs.length > 0) {
    parts.push(attrs.join(' '));
  }

  return parts.join(' ');
}

function generateRelation(relation: Relation, entity: Entity, project: GyxerProject): string {
  const lines: string[] = [];

  if (relation.type === 'one-to-many' && relation.foreignKey) {
    // This side has the foreign key (many side)
    const fk = relation.foreignKey;
    const fkColumn = toSnakeCase(fk);
    lines.push(`  ${padRight(fk, 14)} Int`);
    lines.push(
      `  ${padRight(relation.name, 14)} ${relation.target} @relation(fields: [${fk}], references: [id], onDelete: ${toPrismaAction(relation.onDelete)})`,
    );
    if (fk !== fkColumn) {
      // Already handled by field @map
    }
  } else if (relation.type === 'one-to-many') {
    // This side is the "one" side — just an array relation
    lines.push(`  ${padRight(relation.name, 14)} ${relation.target}[]`);
  } else if (relation.type === 'one-to-one') {
    if (relation.foreignKey) {
      const fk = relation.foreignKey;
      lines.push(`  ${padRight(fk, 14)} Int      @unique`);
      lines.push(
        `  ${padRight(relation.name, 14)} ${relation.target} @relation(fields: [${fk}], references: [id], onDelete: ${toPrismaAction(relation.onDelete)})`,
      );
    } else {
      lines.push(`  ${padRight(relation.name, 14)} ${relation.target}?`);
    }
  } else if (relation.type === 'many-to-many') {
    lines.push(`  ${padRight(relation.name, 14)} ${relation.target}[]`);
  }

  return lines.join('\n');
}

/**
 * Generate the inverse (back-reference) relation field when only one side is defined.
 * Prisma requires both sides of a relation to be present.
 */
function generateInverseRelation(sourceRelation: Relation, sourceEntity: Entity): string {
  const lines: string[] = [];
  const sourceName = sourceEntity.name.charAt(0).toLowerCase() + sourceEntity.name.slice(1);

  if (sourceRelation.type === 'one-to-many') {
    if (sourceRelation.foreignKey) {
      // Source is the "many" side with FK → this entity is the "one" side → needs array
      lines.push(`  ${padRight(sourceName + 's', 14)} ${sourceEntity.name}[]`);
    } else {
      // Source is the "one" side with array → this entity is the "many" side → needs FK
      const fk = `${sourceName}Id`;
      lines.push(`  ${padRight(fk, 14)} Int`);
      lines.push(
        `  ${padRight(sourceName, 14)} ${sourceEntity.name} @relation(fields: [${fk}], references: [id], onDelete: ${toPrismaAction(sourceRelation.onDelete)})`,
      );
    }
  } else if (sourceRelation.type === 'one-to-one') {
    if (sourceRelation.foreignKey) {
      // Source owns the FK → this entity is the inverse → optional ref
      lines.push(`  ${padRight(sourceName, 14)} ${sourceEntity.name}?`);
    } else {
      // Source has optional ref → this entity needs FK + relation
      const fk = `${sourceName}Id`;
      lines.push(`  ${padRight(fk, 14)} Int      @unique`);
      lines.push(
        `  ${padRight(sourceName, 14)} ${sourceEntity.name} @relation(fields: [${fk}], references: [id], onDelete: ${toPrismaAction(sourceRelation.onDelete)})`,
      );
    }
  } else if (sourceRelation.type === 'many-to-many') {
    // Both sides need arrays
    lines.push(`  ${padRight(sourceName + 's', 14)} ${sourceEntity.name}[]`);
  }

  return lines.join('\n');
}

function mapFieldType(field: Field, entity: Entity): string {
  switch (field.type) {
    case 'string':
      return 'String';
    case 'text':
      return 'String';
    case 'int':
      return 'Int';
    case 'float':
      return 'Float';
    case 'boolean':
      return 'Boolean';
    case 'datetime':
      return 'DateTime';
    case 'json':
      return 'Json';
    case 'uuid':
      return 'String';
    case 'enum':
      return `${entity.name}${capitalize(field.name)}`;
    default:
      return 'String';
  }
}

/** Map schema onDelete values (SCREAMING_CASE) to Prisma format (PascalCase). */
function toPrismaAction(action: string): string {
  const map: Record<string, string> = {
    CASCADE: 'Cascade',
    SET_NULL: 'SetNull',
    RESTRICT: 'Restrict',
    NO_ACTION: 'NoAction',
  };
  return map[action] || 'Cascade';
}

/**
 * Generate a full User model for auth-jwt when no User entity exists in the project.
 * Provides the minimal fields needed by the auth module: email, name, passwordHash.
 */
function generateAuthUserModel(): string {
  const lines: string[] = [];
  lines.push('/// Auto-generated User model for auth-jwt module');
  lines.push('model User {');
  lines.push('  id            Int      @id @default(autoincrement())');
  lines.push('  createdAt     DateTime @default(now())');
  lines.push('  updatedAt     DateTime @updatedAt');
  lines.push('  email         String   @unique');
  lines.push('  name          String');
  lines.push('  passwordHash  String   @map("password_hash")');
  lines.push('');
  lines.push('  @@map("user")');
  lines.push('}');
  return lines.join('\n');
}

function capitalize(str: string): string {
  return str.charAt(0).toUpperCase() + str.slice(1);
}

function padRight(str: string, len: number): string {
  return str.padEnd(len);
}
