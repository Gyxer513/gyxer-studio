import type { GyxerProject, Entity, Field, Relation } from '@gyxer/schema';
import { toSnakeCase } from '../utils.js';

/**
 * Generate a complete Prisma schema from a GyxerProject.
 */
export function generatePrismaSchema(project: GyxerProject): string {
  const lines: string[] = [];

  // Datasource
  lines.push('// This file is auto-generated by Gyxer Studio. Do not edit manually.');
  lines.push('');
  lines.push('generator client {');
  lines.push('  provider = "prisma-client-js"');
  lines.push('}');
  lines.push('');
  lines.push('datasource db {');
  lines.push(`  provider = "${project.settings.database}"`);
  lines.push('  url      = env("DATABASE_URL")');
  lines.push('}');

  // Enums
  for (const entity of project.entities) {
    for (const field of entity.fields) {
      if (field.type === 'enum' && field.enumValues && field.enumValues.length > 0) {
        const enumName = `${entity.name}${capitalize(field.name)}`;
        lines.push('');
        lines.push(`enum ${enumName} {`);
        for (const value of field.enumValues) {
          lines.push(`  ${value}`);
        }
        lines.push('}');
      }
    }
  }

  // Models
  for (const entity of project.entities) {
    lines.push('');
    lines.push(generateModel(entity, project));
  }

  return lines.join('\n') + '\n';
}

function generateModel(entity: Entity, project: GyxerProject): string {
  const lines: string[] = [];

  if (entity.description) {
    lines.push(`/// ${entity.description}`);
  }
  lines.push(`model ${entity.name} {`);

  // id field (always generated)
  lines.push('  id        Int      @id @default(autoincrement())');
  lines.push('  createdAt DateTime @default(now())');
  lines.push('  updatedAt DateTime @updatedAt');

  // User-defined fields
  for (const field of entity.fields) {
    lines.push(`  ${generateField(field, entity)}`);
  }

  // Relations
  for (const relation of entity.relations) {
    lines.push(generateRelation(relation, entity, project));
  }

  // Table mapping
  lines.push('');
  lines.push(`  @@map("${toSnakeCase(entity.name)}")`);
  lines.push('}');

  return lines.join('\n');
}

function generateField(field: Field, entity: Entity): string {
  const parts: string[] = [];

  // Name
  const columnName = toSnakeCase(field.name);
  parts.push(padRight(field.name, 14));

  // Type
  let prismaType = mapFieldType(field, entity);
  if (!field.required) {
    prismaType += '?';
  }
  parts.push(prismaType);

  // Attributes
  const attrs: string[] = [];

  if (field.unique) attrs.push('@unique');
  if (field.index) attrs.push('@index');

  if (field.default !== undefined && field.default !== null) {
    if (field.type === 'boolean') {
      attrs.push(`@default(${field.default})`);
    } else if (field.type === 'int' || field.type === 'float') {
      attrs.push(`@default(${field.default})`);
    } else if (field.type === 'enum') {
      attrs.push(`@default(${field.default})`);
    } else {
      attrs.push(`@default("${field.default}")`);
    }
  }

  if (field.name !== columnName) {
    attrs.push(`@map("${columnName}")`);
  }

  if (attrs.length > 0) {
    parts.push(attrs.join(' '));
  }

  return parts.join(' ');
}

function generateRelation(relation: Relation, entity: Entity, project: GyxerProject): string {
  const lines: string[] = [];

  if (relation.type === 'one-to-many' && relation.foreignKey) {
    // This side has the foreign key (many side)
    const fk = relation.foreignKey;
    const fkColumn = toSnakeCase(fk);
    lines.push(`  ${padRight(fk, 14)} Int`);
    lines.push(
      `  ${padRight(relation.name, 14)} ${relation.target} @relation(fields: [${fk}], references: [id], onDelete: ${relation.onDelete})`,
    );
    if (fk !== fkColumn) {
      // Already handled by field @map
    }
  } else if (relation.type === 'one-to-many') {
    // This side is the "one" side â€” just an array relation
    lines.push(`  ${padRight(relation.name, 14)} ${relation.target}[]`);
  } else if (relation.type === 'one-to-one') {
    if (relation.foreignKey) {
      const fk = relation.foreignKey;
      lines.push(`  ${padRight(fk, 14)} Int      @unique`);
      lines.push(
        `  ${padRight(relation.name, 14)} ${relation.target} @relation(fields: [${fk}], references: [id], onDelete: ${relation.onDelete})`,
      );
    } else {
      lines.push(`  ${padRight(relation.name, 14)} ${relation.target}?`);
    }
  } else if (relation.type === 'many-to-many') {
    lines.push(`  ${padRight(relation.name, 14)} ${relation.target}[]`);
  }

  return lines.join('\n');
}

function mapFieldType(field: Field, entity: Entity): string {
  switch (field.type) {
    case 'string':
      return 'String';
    case 'text':
      return 'String';
    case 'int':
      return 'Int';
    case 'float':
      return 'Float';
    case 'boolean':
      return 'Boolean';
    case 'datetime':
      return 'DateTime';
    case 'json':
      return 'Json';
    case 'uuid':
      return 'String';
    case 'enum':
      return `${entity.name}${capitalize(field.name)}`;
    default:
      return 'String';
  }
}

function capitalize(str: string): string {
  return str.charAt(0).toUpperCase() + str.slice(1);
}

function padRight(str: string, len: number): string {
  return str.padEnd(len);
}
